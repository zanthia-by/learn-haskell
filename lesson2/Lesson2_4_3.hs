module Demo2_4_3 where
  
--Show  show
--show :: Show a => a -> String

--show 5  ==> "5"
--show 5.0  ==> "5.0"
-- show [1,2]  ==> "[1,2]"

--обратное действие
--read :: Read a => String -> a

--read "5"  ==> error
--когда что-то полиморфно по возвращаемому значению, мы должны снаять полиморфизм
--read "5" :: Int  ==> 5
--read "5" :: Double  ==> 5.0
--read "[1, 2]" :: [Double]  ==> [1.0,2.0]

--reads возвращает список
-- reads "5 rings" :: [(Int, String)]  ==> [(5," rings")]
--если все ОК - 1 эл-т в списке
--failed - пустой список
--несколько элементов, если синтаксический разбор оказался неоднозначным - возвращает все возможные варианты этого синтаксического разбора

--Пример когда read возвращает несколько элементов
data T = A | B deriving Show

instance Read T where
  readsPrec _ s = 
    [ (A,t) | ("A",t) <- lex s ] ++
    [ (B,x) | ("A",t) <- lex s, ("B",x) <- lex t ] 
    
--(reads "A B C") :: [(T,String)]  ==> [(A," B C"),(B," C")]


----------

--Имея функцию 
ip = show a ++ show b ++ show c ++ show d
--определите значения a, b, c, d так, чтобы добиться следующего поведения:
--GHCi> ip
--"127.224.120.12"

a = 127.2
b = 24.1
c = 20.1
d = 2