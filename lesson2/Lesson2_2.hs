--параметрический полиморфизм (продолжение)
module Demo2_2 where
import Data.Function
  
--композиция ф-ций f и g
--f :: b -> c
--g :: a -> b
--x :: a
--f (g x) :: c

-- композиция ф-ций:
-- \x -> f (g x) :: a -> c
compose f g = \x -> f (g x)

--то же самое, что и compose, делает стандартный оператор (.)


sumFstFst = (+) `on` helper
  where helper pp = fst $ fst pp

sumFstFst' = (+) `on` (\pp -> fst $ fst pp)

sumFstFst'' = (+) `on` (fst . fst)

--Цепочка последовательных применений (функций одного аргумента) может быть заменена композицией
--doIt x = f (g (h x))
--doIt = f . g. h
--называется бесточесный стиль (сократили x справа и слева)
--Термин "бесточечный" используют в том смысле, что в выражении отсутствует "точка применения" (в данном случае аргумент x)
--композиция функций ассоциативна

----------

--Функция одной переменной doItYourself выбирает наибольшее из переданного ей аргумента и числа 42, 
--затем возводит результат выбора в куб и, наконец, вычисляет логарифм по основанию 2 от полученного числа. 
--Эта функция реализована в виде:

doItYourself = f . g . h

--Напишите реализации функций f, g и h. Постарайтесь сделать это в бесточечном стиле.

f = (2 `logBase` ) 
g = (^ 3) 
h = (42 `max`)

----------
--(True,3) 
--(,) True 3 -- префиксный стиль
--(,) конструктор кортежа
--(,,) True 3 'a'

dup x = (x, x)
--dup :: t -> (t, t)

----------
--Каррирование
--комбинатор on:
--on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
--on op f x y = f x `op` f y

--fst - не каррированная, поэтому:
-- fst `on` (^2) ==> error
-- curry fst `on` (^2) ==> :type Num c => c -> c -> c

--некаррированная ф-ция
avg :: (Double, Double) -> Double
avg p = (fst p + snd p) / 2

-- ф-ции высших порядков обычно требуют каррированые ф-ции:
-- :type curry avg `on` (^2)  ==>  Double -> Double -> Double

my_curry f x y = f (x, y)
--my_curry :: ((t1, t2) -> t) -> t1 -> t2 -> t

--curry :: ((a, b) -> c) -> a -> b -> c
--uncurry :: (a -> b -> c) -> (a, b) -> c

----------
--Ответы:
--curry id эквавалентно (,)

--uncurry (flip const) эквивалентно snd

--В модуле Data.Tuple стандартной библиотеки определена функция swap :: (a,b) -> (b,a), переставляющая местами элементы пары:
--swap (1,'A') ==> ('A',1)
--Эта функция может быть выражена в виде:
--swap = f (g h)
--где f, g и h — некоторые идентификаторы из следующего набора:
--curry uncurry flip (,) const

swap = f' (g' h')
f' = uncurry
g' = flip
h' = (,)

-- h' :: a -> b -> (a, b)
-- (g' h') :: b -> a -> (a, b)
-- f' (g' h') :: (a, b) -> (b, a)
