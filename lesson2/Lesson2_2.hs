--параметрический полиморфизм (продолжение)
module Demo2_2 where
import Data.Function
  
--композиция ф-ций f и g
--f :: b -> c
--g :: a -> b
--x :: a
--f (g x) :: c

-- композиция ф-ций:
-- \x -> f (g x) :: a -> c
compose f g = \x -> f (g x)

--то же самое, что и compose, делает стандартный оператор (.)


sumFstFst = (+) `on` helper
  where helper pp = fst $ fst pp

sumFstFst' = (+) `on` (\pp -> fst $ fst pp)

sumFstFst'' = (+) `on` (fst . fst)

--Цепочка последовательных применений (функций одного аргумента) может быть заменена композицией
--doIt x = f (g (h x))
--doIt = f . g. h
--называется бесточесный стиль (сократили x справа и слева)
--Термин "бесточечный" используют в том смысле, что в выражении отсутствует "точка применения" (в данном случае аргумент x)
--композиция функций ассоциативна

----------

--Функция одной переменной doItYourself выбирает наибольшее из переданного ей аргумента и числа 42, 
--затем возводит результат выбора в куб и, наконец, вычисляет логарифм по основанию 2 от полученного числа. 
--Эта функция реализована в виде:

doItYourself = f . g . h

--Напишите реализации функций f, g и h. Постарайтесь сделать это в бесточечном стиле.

f = (2 `logBase` ) 
g = (^ 3) 
h = (42 `max`)